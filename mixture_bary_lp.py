import pdb
import numpy as np
from scipy.stats.stats import ttest_ind_from_stats
import utils
from scipy.stats import gaussian_kde, norm
import matplotlib.pyplot as plt
from progress.bar import Bar
from scipy.integrate import quad


def sample_gaussian_mixture(num_samples, means, sigmas, weights):
    samples = []
    sort = np.argsort(weights)
    inv_sort = { sort[k]:k for k in range(weights.size) }
    sorted_weights = np.sort(weights)
    weights_increments = np.cumsum(sorted_weights)

    uniforms = np.random.uniform(size=num_samples)
    for i in range(num_samples):
        sorted_inter_index = np.nonzero(uniforms[i] < weights_increments)[0][0]
        inter_index = inv_sort[sorted_inter_index]
        samples.append(np.random.normal(loc=means[inter_index], scale=sigmas[inter_index]))
    
    samples = np.array(samples)
    return samples


def invert_cdf_at_point(f, a, b, y, tolerance=1e-8, maxiter=1000):
    if a > b:
        raise ValueError('Interval bounds must be ordered as: a <= b.')
    min_bound, max_bound = a, b

    for _ in range(maxiter):
        x = (min_bound + max_bound) / 2
        y_x = f(x)
        if np.abs(y - y_x) < tolerance:
            break

        if y_x < y:
            min_bound = x
        else:
            max_bound = x
    
    return x


def invert_cdf(cdf, a, b, tolerance=1e-8, maxiter=1000):
    inv_cdf = lambda y: invert_cdf_at_point(cdf, a, b, y, tolerance=tolerance, maxiter=maxiter)

    return inv_cdf


def transport_map(weights, densities, a, b):
    cdfs = [lambda x,i=i: quad(densities[i], -np.inf, x)[0] for i in range(len(weights))]
    cdf_invs = [invert_cdf(cdfs[i], a, b, tolerance=1e-10) for i in range(len(weights))]
    trans_map = lambda x: np.sum([weights[i] * cdf_invs[i](cdfs[0](x)) for i in range(len(weights))])

    return trans_map


# transported_samples follow the distribution of cdfs[0]: denoting F_i the CDF of the
# i-th marginal \mu_i; we have transported_samples \sim \mu_1 and the barycenter
# samples are generated by ((\sum weights[i] F_i^{-1} \circ F_1) \pf F_1)(transported_samples).
#
# time complexity: let \delta < 1 be the tolerance for cdf inversion, n be the number of marginals,
#   m be the number of points in the mesh, and N be the number of samples; then this function
#   has runtime O(-n m N \log \delta).
def barycenter_density(weights, densities, samples_0, mesh, verbose=False):
    num_marginals, num_samples, dim = len(weights), samples_0.shape[0], samples_0.ndim

    cdf0 = lambda x: quad(densities[0], -np.inf, x)[0]
    transported_samples = np.zeros((num_marginals, num_samples, dim))

    if verbose:
        bar = Bar('Sampling barycenter', max=num_marginals*num_samples)

    for marginal in range(num_marginals):
        cdf = lambda x: quad(densities[marginal], -np.inf, x)[0]
        cdf_inv = invert_cdf(cdf, mesh.min(), mesh.max())

        for sample in range(num_samples):
            transported_samples[marginal, sample] = weights[marginal]*cdf_inv(cdf0(samples_0[sample]))
            
            if verbose:
                bar.next()
    if verbose:
        bar.finish()
        
    samples = np.sum(transported_samples, axis=0)
    density = gaussian_kde(np.squeeze(samples))

    return density


def barycenter_density_gaussian_mixture(lambdas, mixture_bundle, gaussian_bundle, mesh, verbose=False, num_samples=1000):
    means, sigmas, weights = mixture_bundle['means'], mixture_bundle['sigmas'], mixture_bundle['weights']
    mixture_samples = sample_gaussian_mixture(num_samples, means, sigmas, weights)
    mixture_kde = gaussian_kde(mixture_samples)

    cdf_samples_density = lambda x: mixture_kde.integrate_box_1d(low=-np.inf, high=x)
    if verbose:
        print('\n(b_d_g_m)  Inverting CDF ({} samples)...'.format(num_samples))
    icdf_gaussian = invert_cdf(lambda x: norm.cdf(x, loc=gaussian_bundle['mean'], scale=gaussian_bundle['sigma']), mesh.min(), mesh.max())
    transport_map_ = lambda x: icdf_gaussian(cdf_samples_density(x))
    gaussian_samples = np.array([transport_map_(s) for s in mixture_samples])
    barycenter_samples = np.sum([ell*s for (ell, s) in zip(lambdas, [mixture_samples, gaussian_samples])], axis=0)
    if verbose:
        print('(b_d_g_m)  Done.')
    density_kde = gaussian_kde(barycenter_samples, bw_method='scott')
    density = density_kde.pdf

    return density, transport_map_, density_kde


def sample_cdf(cdf, lower_bound, upper_bound, num_samples, tolerance=1e-8, maxiter=1000):
    uniforms = np.random.uniform(size=num_samples)
    samples = np.array([invert_cdf_at_point(cdf, lower_bound, upper_bound, u, tolerance=tolerance, maxiter=maxiter) for u in uniforms])

    return samples


if __name__ == '__main__':
    test_bary_sampling = False
    test_sample_density = True

    if test_sample_density:
        num_samples = 300
        density = lambda x: 0.5*np.exp(-0.5*x**2) / np.sqrt(2*np.pi) + 0.5*np.exp(-0.5*(x-2)**2 / 0.5**2) / np.sqrt(2*np.pi*0.5**2) 
        samples = sample_density(density, -6, 6, num_samples, tolerance=1e-4)

        mesh = np.linspace(-6, 6, 500)
        plt.grid()
        plt.plot(mesh, density(mesh), c='red')
        plt.hist(samples, bins=30, density=True)
        plt.show()


    if test_bary_sampling:
        mesh = np.linspace(-10, 10, 500)
        num_samples = 1000
        means, sigmas, weights = np.array([-2.5, 1]), np.array([0.5, 1]), np.array([0.3, 0.7])
        gaussian_densities = utils.gaussian_mixture_densities(means, sigmas)
        mixture_samples = sample_gaussian_mixture(num_samples, means, sigmas, weights)
        mixture_kde = gaussian_kde(mixture_samples)

        marginal_densities = []
        marginal_densities.append(mixture_kde.pdf)
        marginal_densities.append(lambda x: np.exp(-0.5*(x - 5)**2) / np.sqrt(2*np.pi))

        num_barycenters = 1
        barycenters = []
        bar = Bar('Runs', max=num_barycenters)
        for n in range(num_barycenters):
            alpha = 0.5#1 - (n+1)/num_barycenters
            lambdas = np.array([alpha, 1 - alpha])

            density, trans_map = barycenter_density_gaussian_mixture(lambdas, {'means': means, 'sigmas': sigmas, 'weights': weights}, \
                {'mean': 5, 'sigma': 1}, mesh, verbose=True, num_samples=500)

            barycenters.append(density)
            #barycenters.append(barycenter_density(lambdas, marginal_densities, mixture_samples, mesh, verbose=True))

            bar.next()
        bar.finish()


        plt.grid()
        eval_densities = np.array([gaussian_densities(x) for x in mesh]).reshape((mesh.size, -1)).T
        plt.plot(mesh, weights.dot(eval_densities), c='blue', label='Mixture density')
        plt.plot(mesh, mixture_kde.pdf(mesh), c='black', label='Mixture estimate')
        plt.hist(mixture_samples, color='blue', alpha=0.3, density=True, bins=50, label='Sample histogram')
        plt.plot(mesh, (lambda x: np.exp(-(x - 5)**2 / 2) / np.sqrt(2*np.pi))(mesh), c='black', label='Gaussian')
        for i, density in enumerate(barycenters):
            plt.plot(mesh, density(mesh), alpha=0.4, label='Barycenter {}'.format(i))
        ax = plt.gca()
        axi = ax.inset_axes([0.02, 0.5, 0.32, 0.35])
        #trans_map = transport_map(lambdas, marginal_densities, mesh.min(), mesh.max())
        print('Transporting points...')
        transport_points = np.array([trans_map(x) for x in mesh])
        axi.grid()
        axi.set_xlim([-5, 5])
        axi.set_ylim([-5, 5])
        axi.plot(transport_points, mesh, c='gray')
        plt.legend()
        plt.show()
